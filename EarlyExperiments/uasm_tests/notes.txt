# Построение EXE-файла
# https://habr.com/ru/post/515058/


# Комментарий
# Пробую придумать универсальный синтаксис для переопределяемого ассемблера
# ПО СУТИ это язык, который буквально на выходе задает байты
# Соответственно задавать можно что угодно, вплоть до ручного написания байтов
# Но я хочу сделать так что бы можно было определять свои ассемблеры и форматы файлов
# За основу я взял переопределяемый ассемблер из игры Virtual Circuit Board (VCB)
# Но в VCB ассемблер ограничен 4-х байтовыми словами.
# Я хочу более универсальный ассемблер.
# Однако тут есть и главный минус - оригинал из VCB довольно прост. Универсальность сильно усложнит его.

# Символы и строки
# И инструкция включения файла в текущий компилируемый файл
include 'def.x86.uasm'
include 'def.exe_header.uasm'
# строки, кстати, парсить как utf8 или как ascii? ВОПРОС!

# Определение символов
symbol  MOV         NEXT    0b01_000_000
symbol  MOV.ax      OR      0b00_001_000    # разные типы сборки байтов
symbol  MOV._.ax    OR      0b00_000_001    # OR означает что текущий байт будет объединен с ранее вставленным байтом через побитовое OR
symbol  JMP         NEXT    0b10__000000    # NEXT - что новый байт вставляется ПОСЛЕ
symbol  FAR         NEXT    0b11__000000    # Возможно еще нужно залать AND
# Возможно стоит ставить ключи OR, AND, NEXT после значения
# Синтаксис с точками и прочерками - условная компиляция символа - символ задается при условии что перед ним шли определенные символы

# Вообще в рамках VCS в отдельном выражении все элементы OR-ятся вместе.
# НО. Там всегда фиксированный размер в 4 байта. А поскольку я хочу поддержку разноразмерных команд, то мне нужно явно задавать поведение.
# Это в свою очередь освобождает меня от привязки к выражению
# можно написать MOV ax, ax MOV bx, bx в одну строку и это все равно сгенерирует две отдельные команды.

# Макросы?
# Макросы позволят сильно расширять языки на ходу
# Но и усложнят синтаксис. Плюс у меня возникают мысли, что возможно стоит задавать директивы не просто словами,
# а словами со спецсимволом, что бы их можно было отличать. Как в C например #define
macros  NAME    arg1 arg2 arg3
    # тут можно по идее сделать подстановку множества строк, да еще и с вложенным исполнением макросов
    # почитал про макросы в С/С++ - там они оказывается ВСЕГДА ОДНОСТРОЧНЫЕ. Мама не горюй))
end

# Остается вопрос с однострочными макросами.
# Нужны? И если да, то какие и для чего

# Выражения, вычислимые на этапе компиляции
# Это тоже взято из VCB
# любое выражение в скобках, использующее основные математические операции
	( MOV + DROP * 15 )
# Это впринципе логично

# Указатели
# По сути указатель должен брать текущий адрес сборки.
# По эквивалентно
# symbol .pointer $ CLR
# $ означает текущий адрес байта при ассемблировании
.pointer
    MOV ax, ax      # 0b01_000_000 | 0b00_001_000 | 0b00_000_001 -> 0b01_001_001
    JMP .pointer    # 0b10__000000 0b(АДРЕС pointer-а)

# Что делать если я хочу в зависимости от расстояния ставить разные виды команды?
# А может хер забить?
    JMP ($ - .pointer)      # Локальный прыжок? А какой размер байт тут должен быть?
    JMP ($ - .pointer){2}   # Если вот так... то мы уже имеем слишком много разных определений!
    # То есть тут вопрос в том, как из рассчетов выводить желаемое колличество байт.

# Откуда ноги у этого вопроса?
# В ассемблерах x86 есть разные команды перехода, рассчитанные на разное расстояние прыжка
# И если расстояние меньчше 127 то аргумент занимает 1 байт, иначе 2 или 4
# А это значит что мне как-то надо примитиву задавать размер

# Например у нас есть символ PTR, имеющий в себе число размером в 4 байта
# И надо это число обрезать до одного
# Как это записать так что бы не сильно выбивалось из концепции переопределяемого ассемблера?
# Окей, тип команды определим дополнительным суффиксом
symbol  JMP    NEXT     0x80
symbol  NEAR   OR       0x00
symbol  LONG   OR       0x81
# Тогда как красивее записать изменение размера байтов
    JMP NEAR .PTR        # Будет 5 байт, инструкция и адрес: 0x80 0xXXXXXXXX
    JMP NEAR ($-.PTR)    # Будет 5 байт, инструкция и адрес: 0x80 0xYYYYYYYY, но адрес теперь относительный
    JMP NEAR PTR:REL    # В таком виде можно задать что бы было 0x80 0xYY, НО это будет пипец локальный специальный синтаксис для случая
    JMP NEAR ($-.PTR){1}     # Новый синтаксис
    JMP NEAR ($-.PTR)[1]     # Новый синтаксис
    JMP NEAR (byte)($-.PTR)  # Новое ключевое слово + синтаксис

# Еще вариант
symbol  JMP.NEAR.@  NEXT ($ - @)
# здесь собака @ означает ссылку а $ текущую позицию в байтах
# НО, тут придется делать что бы символ ИСПОЛНЯЛСЯ в месте подстановки
# то есть по сути - был разновидностью макроса
    JMP NEAR .PTR
# Но так выглядит система лучше
# Плюс остается вопрос с сокращением до заданного числа байт

# Так... Какие варианты?
($ - @){1}
($ - @)[1]
(byte)($ - @)
(i08)($ - @)
(i16)($ - @)
(i32)($ - @)
i08:($ - @)
i16:($ - @)
i32:($ - @)
1b:($ - @)
2b:($ - @)
b4:($ - @)
($ - @):4b
($ - @):4
1:($ - @)
4:($ - @)

# Выглядит не плохо
# Тогда возвращаясь к макросами

symbol X._.@ NEXT ($ - @)

#Что если добавить это как пременные...
symbol X.@1.@2 NEXT ($ - @2)

# Не хуйня ли получится?
# А как обычные макросы должны работать?

macros GROUP arg1 arg2 arg3
    # символы просто подставляем
    MOV ax, arg1
    MOV bx, arg2
    MOV cx, arg3
end
# тогда
GROUP 1 2 3
# превратится в 
    MOV ax, 1
    MOV bx, 2
    MOV cx, 3
# то есть он должен просто забирать следующие за ним символы в качестве аргументов
# Кстати вопрос, как объявить MOV так, что бы учесть что один из аргументов - байт?
# Пипец язык усложняется....




push cs
pop ds
mov dx, 0x0E
mov ah, 0x09
int 0x21
mov ax, 0x4C01
int 0x21
"This program cannot be run in DOS mode.\x0D\x0A$"




0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21
0E
1F
BA 0E 00
B4 09
CD 21
B8 01 4C
CD 21


00001110
0E
push cs

00011111
1F
pop ds

10111010 00001110 00000000
BA 0E 00
mov dx, 0x0E

10110100 00001001
B4 09
mov ah, 0x09

11001101 00100001
CD 21
int 0x21

10111000 00000001 01001100
B8 01 4C
mov ax, 0x4C01

11001101 00100001
CD 21
int 0x21

"This program cannot be run in DOS mode.\x0D\x0A$" ; Выводимая строка





0x0000000000000000:  0E          push cs
0x0000000000000001:  1F          pop  ds
0x0000000000000002:  BA 0E 00    mov  dx, 0xe
0x0000000000000005:  B4 09       mov  ah, 9
0x0000000000000007:  CD 21       int  0x21
0x0000000000000009:  B8 01 4C    mov  ax, 0x4c01
0x000000000000000c:  CD 21       int  0x21

0x0000000000000000:  0E                push cs
0x0000000000000001:  1F                pop  ds
0x0000000000000002:  BA 0E 00 B4 09    mov  edx, 0x9b4000e
0x0000000000000007:  CD 21             int  0x21
0x0000000000000009:  B8 01 4C CD 21    mov  eax, 0x21cd4c01




symbol MOV.:4.ax (0x0E <: 4)
Если после MOV идёт 4 байта, то байт 0x0E записывается на 4 байта левее

Даже не так

По сути все что мы делаем - меняем байты и биты
А это значит что нам нужно отталкиваться от операций, которые меняют байты и биты
И смещают каретку 🧐

А таких операций всего три:
- сдвиг указателя
- установка режима записи (SET, AND, OR)
- и, собственно, запись!

И тогда любой сложный символ - просто пачка операций, обмазанных синтаксическим сахаром!

Останется решить как присовокупить условное исполнение.

И по сути получается что мы создали не язык, который компилируется, а язык, который интерпретируется и у которого только одна операция - запись байта в буфер по адресу!

У меня как обычно приступ гениальности во втором часу ночи 😅

symbol MOV 0x80
symbol MOV [ SET 0x80 :> 1 ]
symbol MOV.:4.AX [ <: 4 OR 0x0C :> 5 ]

Что-то такое

Блин
Это близко по смыслу к FORTH, но не то же самое
Но прикольно выходит


Еще упростим, и получим базовый язык операций:
Сдвиги:
  <4 влево на 4 байта
  5> вправо на 5 байт
Запись одного байта
  0x00
  0b00000000
  0xFFFFFFFF запись 4 байт
Задание режима записи байт
  SET       Байты замещают текущие байты (просто присвоение)  
  OR        Байты добавляются в текущую позицию через операцию побитового ИЛИ
  AND       Байты добавляются в текущую позицию через операцию побитового И
  XOR       Байты добавляются в текущую позицию через операцию побитового исключаещего ИЛИ
  APPEND    То же что SET, но дополнительно автоматом смещают каретку на колличество байт

UPD
Нам все еще нужно в рамках базового языка иметь математические выражения, текущее смещение и возможность применять результаты выражений в качестве параметра как к записи так и к смещению.





И в итоге в основе получается язык, похожый на brainfuck

Только теперь надо еще ввести условные операции

Одну условную операцию я задал в виде паттерн-матчинга

symbol A._.B 

это означает что когда у нас в потоке будет символ B и при том два символа назад был A, то будут выполнены определенные операции

но это матчинг только для предыдущих символов
тут сразу можно увидеть что можно задавать пустые символы:
symbol EMPTY []

Можно добавить макрос, который будет "съедать"  символы после себя.

Остается вопрос, насколько этого хватит для определения логики?

То есть например если при компиляции должны выполнятся разные операции в зависимости от входного значения макроса?

ЕСТЬ ИДЕЯ

macros NAME.ARG1.ARG2._.ARGN [ ... ]

ТОТ ЖЕ ПТТЕРН МАТЧИНГ, но с противоположного хвоста!

еба...
Я гений извращенец!

Остается вопрос: что делать с аргументами, которые скипнуты _ или если нет соответствия?
при несоответствии - ошибка компиляции
а при пропуске?...
исполнять аргумент как если бы не было макроса?
ммм... пока один вариант - исполнять аргумент после исполнения макроса.
Хотя звучит как сильно непредсказуемое поведение




0 0000
1 0001
2 0010
3 0011
4 0100
5 0101
6 0110
7 0111
8 1000
9 1001
A 1010
B 1011
C 1100
D 1101
E 1110
F 1111

10001000 11100100
88 E4    mov ah, ah
10001000 11101101
88 ED    mov ch, ch
10001000 11110110
88 F6    mov dh, dh
10001000 11111111
88 FF    mov bh, bh













Итого, что получается с языком?

Интерпретатор просто последовательно выполняет слова из входного потока.

Текст программы парсится и делится на такие токены:
Символы - либое слово из букв и цифр. Есть ряд заранее определенных символов со своим поведением.
Спецсимволы - пока вижу только $ для текущего положения в памяти.
Байты - Либо в виде байтов 0xFF, 0b1000 либо в виде строк 'Hello, world!'
Скобки
[ ] квадратные скобки означают подстановку - все символы из квадратных скобок при их исполнении подставляются в поток и исполняются. По сути группировка нескольких символов в один.
( ) круглые скобки означают математическое выражение. Символы внутри него преобразуются в соответствующие им числа, результат интерпретируется в зависимости от символов снаружи. Выражение в скобках исполняется или сразу или отложенно (как в случае с символами)

Заранее определенные символы:

Символы смещения
  LEFT - смещает коретку влево на число, указанное в следующем символе
  RIGHT - смещает коретку вправо на число, указанное в следующем символе
Для этих символов синтаксический сахар: <N и N> для смещения на N влево и вправо соответственно.
<N эквивалентно LEFT N

Символы записи, применяется к следующему за ним набору байтов
  SET B     Байты B замещают текущие байты (просто присвоение)  
  OR B      Байты B добавляются в текущую позицию через операцию побитового ИЛИ
  AND B     Байты B добавляются в текущую позицию через операцию побитового И
  XOR B     Байты B добавляются в текущую позицию через операцию побитового исключаещего ИЛИ
  APPEND B  То же что SET, но дополнительно автоматом смещают каретку на колличество байт
Если ни один символ записи не указан, то байты дописываются через APPEND
Таким образом всякие заголовочные файлы буквально будут записываться через прямое объявление байтов.
Это позволит достаточно легко и без гемора делать многие штуки.

Символы определений
  symbol NAME SYMBOL - вместо квадратных скобок может быть просто атомарный символ. Байты или иные символы. Таким образом можно задавать алиасы. Выражения symbol NAME SYMBOL и macros NAME SYMBOL по своей сути эквивалентны.
  symbol NAME [ ... ]
  macros NAME [ ... ]
  symbol A.B.C.NAME [ ... ]
  macros NAME.A.B.C [ ... ]
Оба варианта поддерживают паттерн-матчинг.
Только символ матчит для данного имени предыдущие символы, а макрос - следующие.
Элементы матчинга могут быть символами, байтами, пропуском _ и аргументами $arg, которые далее будут подставляться в теле символа/макроса

Символы работы с байтовыми массивами... ведь математические операции могут упираться в разный размер байтовых массивов например

Иии...
Я наизобретал целый мега-язык.
Если выкинуть из него тему с кареткой и байтами, то у нас останется некоторый абстрактный конкатенативный язык программирования, в котором все упирается в модификацию потока символов.
И я не помню, видел ли я такие языки.